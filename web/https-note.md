# HTTPS Note

## References

- [一个故事讲完 HTTPS](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513779&idx=1&sn=a1de58690ad4f95111e013254a026ca2&chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&scene=21)
- [深度解析 HTTPS 原理](http://blog.csdn.net/zhongzh86/article/details/69389967)
- [HTTPS 原理篇](https://yanhooit.gitbooks.io/ios_study_note/content/httpsyuan_li_pian.html)

## Note

Note from [一个故事讲完 HTTPS](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513779&idx=1&sn=a1de58690ad4f95111e013254a026ca2&chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&scene=21)

刘欣的这篇文章写得简明易懂，看完后我完全理解了 HTTPS 的原理。

涉及五个重要的概念：

- 对称加密 - 加密和解密使用相同的密钥
- 非对称加密 RSA - 加密用公钥，解密则用私钥，反之亦然，公钥人人皆知，私钥只有自己知道
- 哈希算法 - 将任意长度的数据转换成固定长度 (常见 128bit 或 256bit) 的数据，且只要源数据不同，生成的 hash 值就不会相同 (相同的概率极低以至于可以忽略)
- 数字签名 - 将网站信息 (个人信息、公钥、域名等) 数据进行 hash，然后用 CA 的私钥进行加密后得到的值
- 数字证书 - 网站信息和数字签名的打包文件

相比 HTTP 协议使用明文在网络上传递所有信息，容易被拦截窃听，还可能被修改 (比如插入广告、病毒)，为了避免这种安全隐患，人们推出了 HTTPS 协议。

HTTPS 使用对称加密技术，对传递的内容使用密钥进行加密，接收方使用相同的密钥进行解密。

密钥由连接建立时客户端随机产生，并发送给服务端。

问题来了，密钥产生时，显然不能用这个密钥对密钥自身进行加密，如何传递这个密钥呢，如果用明文，那一旦密钥自身被拦截窃取了，后面的加密就全白搭了。

于是人们想到，用非对称加密技术来传递这个对称密钥。

每个网站有自己的公钥和私钥，公钥人人皆知，私钥网站自己掌管。

于是乎，当客户端产生一个随机对称密钥后，它用这个网站的公钥进行加密，网站接收到加密后的内容后，用自己的私钥进行解密，得到公共密钥，然后就用这个公共密钥进行对称加密和客户端通信。

随机密钥被公钥加密后，只有私钥才能对它解密，因此即使被拦截，由于其它人没有私钥，无法对它进行解密，因此保证了这个公共密钥传输的安全。

虽然每个网站的公钥是公开的，人人皆知，但你也得先拿到它啊，怎么拿到它呢，当然是向服务器索取喽，当客户端向服务端进行初次请求时，服务端会把它的公钥发给客户端。

但新的问题又来了，如果有人在中间捣鬼，把这个公钥给替换了呢，这就是所谓的中间人问题。

比如，你通过代理访问一个网站，数据要从这个代理走，当服务端把公钥发给你时，代理从中摆了一道，它把服务端的公钥，替换成了自己的公钥，这样，客户端实际是用代理的公钥加密了对称密钥，那么，当它把数据发回服务端时，代理可以用自己的私钥把这个对称密钥解密出来，然后再用服务端的公钥重新加密，再发回服务端。对此，客户端和服务端毫无查觉。

因此，必须要有一个办法，来确保我所拿到的公钥就是这个网站的公钥。

正如在现实生活中，一些企业或个人需要向权威部门提供一些资料来证明自己的身份，然后权威部门会给他们颁发一个证书来证明他们的身份。

在 HTTPS 体系中，也有一个类似的权威部分，叫 CA (Certificate Authority)，认证中心，它为网站的公钥背书，为它颁发证书来证明它的公钥。

具体流程是这样的：

1. 网站向 CA 申请证书。为了申请证书，网站需要提供一些材料，比如个人信息，网站域名，以及网站的公钥。
1. CA 将这些材料打包，进行 hash，然后用 CA 的私钥对 hash 进行加密，生成的结果称为数字签名。
1. CA 将原来打包的材料，和生成的数字签名一起，再进行一次打包，生成的文件就是这个网站的数字证书。

![](../art/https-certificate.webp)

那么网站得到这个数字证书后，怎么使用呢：

1. 网站把这个数字证书放在自己的服务器上，客户端首次访问时，服务器先把证书发给客户端验证。
1. 客户端得到证书，因为证书中有两部分内容，一部分是打包的网站信息、公钥等，一部分是这些信息的数字签名。客户端首先对网站信息进行 hash，得到 hash 值。然后，它要对数字签名进行解密，因为它是用 CA 的私钥加的密，那么就必须用 CA 的公钥进行解密。CA 的公钥会内置在客户端 (一般是指浏览器)，因此它可以对数字签名进行解密得到另一个 hash，然后将两个 hash 进行对比，如果相同，说明证书是正确的，里面的公钥可以拿来用，反之，说明证书被人篡改了。

![](../art/https-verify.webp)

然后，这个数字证书怎么就可以来防止中间人攻击了呢。要是中间人也向 CA 申请了一个证书，它如果在中间用自己的证书替换了网站的证书，会怎么样呢。

(自己的猜测：这是不可能的，因为证书中包含了域名信息，一个域名只能对应一个正确的证书，客户端得到代理的证书，首先打开证书一看，域名就对不上，这个证书肯定不是服务器发来的)

如果代理想修改证书，除非它有 CA 的私钥，否则它不可能生成正确的数字签名。

综上，中间人攻击基本就可以杜绝了。

最后，整个通信流程如下所示：

![](../art/https-flow.webp)

### 补充

HTTP 和 HTTPS 的协议栈

    HTTP    HTTPS

    HTTP    HTTP
    ----    ----
    TCP     SSL or TLS
    ----    ----
    IP      TCP
            ----
            IP

HTTPS 比 HTTP 多了一层 SSL/TLS。

- SSL (Secure Socket Layer，安全套接字层)
- TLS (Transport Layer Security，传输层安全) - 其前身是 SSL，从 SSL 3.1 开始被 IEFT 标准化并改名为 TLS，目前最广泛版本是 TLS 1.1，TLS 1.2

加密算法：

- 对称加密：AES、DES、3DES ...
- 非对称加密：RSA、ECC、DH ...
- 哈希算法：MD5、SHA-1、SHA-2、SHA-256 ...

HTTPS 中的数字证书为 SSL 证书，其包括的完整内容：

1. 证书的发布机构 CA
1. 证书的有效期
1. 公钥
1. 证书所有者
1. 数字签名
1. ...

客户端 (以浏览器为例) 对证书的校验过程：

1. 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
1. 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发
1. 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的
1. 如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥，然后对服务器发来的证书里面的签名进行解密，解密出 hash 值
1. 浏览器使用相同的 hash 算法计算出服务器发来的证书中除数字签名外的数据的 hash 值，和上一步中得到的 hash 进行对比
1. 对比结果一致，则证明服务器发来的证书合法，没有被冒充
1. 此时浏览器就可以读取证书中的公钥，用于后续加密了

![](../art/https-ca.png)

HTTPS 的缺点：

1. SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐
1. HTTPS 降低用户访问速度 (多次握手)
1. 网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时 (多数网站采用 302 跳转)
1. HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器 (HTTPS 访问过程需要加解密)
