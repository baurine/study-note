# 《MySQL 是怎样运行的：从根儿上理解 MySQL》Note

- [MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.im/book/5bffcbc9f265da614b11b731/section/5bffcbc9f265da61553a8bc9)

## 1. 序

略。

## 2. 装作自己是个小白 —— 重新认识 MySQL

MySQL 是 c/s 架构。

启动客户端访问服务端：`mysql -h主机名 -P端口号 -u用户名 -p密码`，除了 `-p` 和后面的密码之间没有空间，其它选项可以有空格，密码也可以不在 `-p` 后明文输入，而是回车后隐藏式输入。如果在同一台机器上 `-h主机名` 可以省略。如果端口号是默认值，没有修改过，则 `-P端口号` 可以省略。如果用户名和当前系统的用户名一样，则 `-u用户名` 也可以省略。

客户端和服务端通信的几种方式：

- TCP/IP
- 命名管道和共享内存
- Unix 域套接字文件

服务端处理客户端请求：

- part 1 - 处理连接，每一个分配一个线程/线程池
- part 2 - 解析与优化，生成执行计划，可以用 explain 查看生成结果
  - 查询缓存 (在 MySQL 8.0 中删除)
  - 语法解析 (AST)
  - 查询优化
- part 3 - 存储引擎 (最常用 InnoDB 和 MyISAM)

查看当前存储引擎的命令：`SHOW ENGINES;`

创建表时指定存储引擎 / 修改表的存储引擎，略。

## 3. MySQL 的调控按钮 —— 启动选项和系统变量

MySQL 的参数，配置文件。略。

系统变量：

> MySQL 服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为 MySQL 系统变量，比如允许同时连入的客户端数量用系统变量 `max_connections` 表示，表的默认存储引擎用系统变量 `default_storage_engine` 表示，查询缓存的大小用系统变量 `query_cache_size` 表示，MySQL 服务器程序的系统变量有好几百条，我们就不一一列举了。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值。大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它。

查看这些变量：

```
mysql> SHOW [GLOBAL|SESSION] VARIABLES [LIKE pattern];
```

运行时修改系统变量。为了将用户相互间的修改的影响降低最低，将系统变量划分不同的作用范围：

- GLOBAL - 全局变量，影响服务器的整体操作
- SESSION - 会话变量，影响某个客户端连接的操作

修改全局变量：

```
语句一：SET GLOBAL default_storage_engine = MyISAM;
语句二：SET @@GLOBAL.default_storage_engine = MyISAM;
```

修改会话变量：

```
语句一：SET SESSION default_storage_engine = MyISAM;
语句二：SET @@SESSION.default_storage_engine = MyISAM;
语句三：SET default_storage_engine = MyISAM;
```

状态变量：

> 为了让我们更好的了解服务器程序的运行情况，MySQL 服务器程序中维护了好多关于程序运行状态的变量，它们被称为状态变量。比方说 `Threads_connected` 表示当前有多少客户端与服务器建立了连接，`Handler_update` 表示已经更新了多少行记录。

查看状态变量：

```
mysql> SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];
```

(其实，更好的办法是使用 `SELECT @@GLOBAL.xxx` 语法，相关参考：https://github.com/jinzhu/gorm/issues/2616)

## 4. 乱码的前世今生 —— 字符集和比较规则

MySQL 中的 utf8 (实际是 utfbm3) 和 utfbm4

- utf8mb3：阉割过的 utf8 字符集，只使用 1 ～ 3 个字节表示字符。
- utf8mb4：正宗的 utf8 字符集，使用 1 ～ 4 个字节表示字符。

存储 emoji 要用 utfbm4。

查看 MySQL 支持的字符集：

```
SHOW (CHARACTER SET|CHARSET) [LIKE pattern];
```

MySQL 支持 41 种字符集 (TiDB 支持 5 种)

每一种字符集都支持数种比较规则，查看比较规则：

```sql
SHOW COLLATION [LIKE 匹配的模式];
```

比如查看 utf8 的比较规则有哪些：`SHOW COLLATION LIKE 'utf8\_%';`，结果有 27 种。常见的 `utf8_general_ci`, `utf8_bin`, `utf8_spanish_ci`。后缀 `_ci` 表示 case insensitive，如果要区分大小写，用 `_cs` (case sensitive)，`_bin` 表示直接比较它们的二进制大小。

### 字符集和比较规则的应用

MySQL 有 4 个级别的字符集和比较规则，分别是：

- 服务器级别 (相应的系统变量：`character_set_server`, `collation_server`)
- 数据库级别 (系统变量：`character_set_database`, `collation_database`)
- 表级别
- 列级别

单方面修改字符集或比较规则，都会引起另一方的改变。

详略。

#### MySQL 中字符集的转换

涉及的三个系统变量：

- `character_set_client` - 服务器解码请求时使用的字符集
- `character_set_connection` - 服务器处理请求时会把请求字符串从 `character_set_client` 转为 `character_set_connection`
- `character_set_results` - 服务器向客户端返回数据时使用的字符集

字符集转来转去让人头晕，最好的办法是让上面三者的字符符相同。`SET NAMES 字符集名;` 可以把上面三者设置成相同的字符集。

详略。

## 5. 从一条记录说起 —— InnoDB 记录结构

我们前边唠叨请求处理过程的时候提到过，MySQL 服务器上负责对表中数据的读取和写入工作的部分是存储引擎，而服务器又支持不同类型的存储引擎。这里我们只重点探讨 InnoDB 存储引擎。

### InnoDB 页

> 而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB 中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。

(完全理解)

### InnoDB 行格式

(相当于是在定义协议，和定义 TCP/IP 协义类似)

MySQL 是按行来存储记录的 (也有按列存的存储引擎，比如 ClickHouse，这种一般是用来做分析用的)。

MySQL 设计了 4 种行格式：Compact、Redundant、Dynamic 和 Compressed。

指定使用何种行格式：

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称;

ALTER TABLE 表名 ROW_FORMAT=行格式名称;
```

#### Compact 行格式

```
|    记录的额外信息                        ||    记录的真实数据           ｜
| 变长字段长度列表 | NULL 值列表 | 记录头信息 || 列 1 的值 | 列 2 的值 | ... |
```

一行中第一部分为记录的额外信息，分三类：变长字段长度列表，NULL 值列表，记录头信息。第二部分存储所有的非 NULL 值。(因为这是 compact 类型的行，尽可能减少存储空间)

NULL 值列表和记录头信息都用位图表示。记录头信息由固定的 5 个字节组成。5 个字节也就是 40 个二进制位，不同的位代表不同的意思。

细节先暂时跳过。

记录的真实数据：除了自己定义的列的数据外，MySQL 还会为每个记录增加一些默认的列，也称为隐藏列。

- `DB_ROW_ID`，非必须，当这个表没有定义主键或 unique 列时，MySQL 会添加此列作为行 ID，唯一标识一条记录
- `DB_TRX_ID`，必须，事物 ID
- `DB_ROLL_PTR`，必须，回滚指针

`CHAR(M)` 列的存储格式：对于 `CHAR(M)` 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

#### Redundant 行格式

比较老的一种格式了，先跳过。

#### 行溢出

MySQL 按页存储，一页 16KB，一页至少存 2 行。如果一行的某列存储的长度过大，比如 varchar 最大支持 65535 byte，即 64KB，则这一行就溢出了。那 MySQL 如何处理呢，如果出现这种情况，则这一列只存储全部内容的一小部分，剩余内容存储到其它页中，并指页的地址存储在该列中。(就跟文件系统一样的道理)。

具体的细节略过。

#### Dynamic 和 Compressed 行格式

Dynamic 行格式是目前 MySQL 5.7 开始的默认行格式。这两种格式和 Compact 格式相似，只不过在处理行溢出时不同，在 Dynamic 行格式中发生行溢出时，所有内容都会存储到其它页中，只将指针存储在原始列中，原始列中不会存储一小部分真实的内容。

Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间。

## 6. 盛放记录的大盒子 —— InnoDB 数据页结构

不同类型的页：页是 InnoDB 管理存储空间的基本单位，一个页的大小一般是 16KB。InnoDB 为了不同的目的而设计了不同类型的页。

这一小节聚焦在存放表中记录的类型的页。官方称这种类型的页为索引页，为了不和后面真正的索引混淆，这里我们称之为数据页。

就像 ELF/TCP 这些数据格式/协议一样，InnoDB 数据页结构示意如下：

```
File Header (38 bytes) - 页的一些通用信息
---------------------------------------------
Page Header (56 bytes) - 数据页专有的一些信息
---------------------------------------------
Infimum + supremum (26 bytes) - 两个虚拟的行记录
---------------------------------------------
User Records (大小不确定) - 实际存储的行记录内容
---------------------------------------------
Free Space (大小不确定) - 页中尚未使用的空间
---------------------------------------------
Page Directory (大小不确定) - 页中的某些记录的相对位置
---------------------------------------------
File Trailer (8 bytes) - 校验页是否完整
```

### 记录在页中的存储

#### 记录头信息的秘密

上一小节我们讲了记录的行格式，以 Compact 为例：

```
|    记录的额外信息                        ||    记录的真实数据           ｜
| 变长字段长度列表 | NULL 值列表 | 记录头信息 || 列 1 的值 | 列 2 的值 | ... |
```

记录录占 5 字节共 40 位，协议定义如下：

| 名称         | bit | 描述                                                                                         |
| ------------ | --- | -------------------------------------------------------------------------------------------- |
| 预留位 1     | 1   | 没有使用                                                                                     |
| 预留位 2     | 1   | 没有使用                                                                                     |
| delete_mask  | 1   | 标记该记录是否被删除                                                                         |
| min_rec_mask | 1   | B+ 树的每层非叶子节点中的最小记录都会添加该标记                                              |
| n_owned      | 4   | 表示当前记录所在分组拥有的记录数 (分组后面会讲)                                              |
| heap_no      | 13  | 表示当前记录在~~记录堆~~(当前页/分组)的~~位置信息~~(编号)                                    |
| record_type  | 3   | 表示当前记录的类型，0 表示普通记录，1 表示 B+ 树非叶节点记录，2 表示最小记录，3 表示最大记录 |
| next_record  | 16  | 表示下一条记录的相对位置                                                                     |

`delete_mask`: 如果该记录被删除，此 bit 被标记为 1，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

`heap_no`: 表示当前记录在此页中的编号，从 2 开始计数，如果此页中有 4 条记录，那 `heap_no` 分别是 2/3/4/5。0 和 1 去哪了？0 和 1 给了两个虚拟行记录 Infimum 和 Supremum，前者用来表示最小记录，后者表示最大记录，用于后面会讲到的行记录比较。前者列中的数据为固定的 "infimum" 字符，后面列中的数据为固定的 "supremum" 字符。

`next_record`: 它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量，形成链表。下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录（也就是最大记录）。(数据库中的行记录都是按主键排好序的，并不是按插入的顺序依次存放)

前面说到行记录的记录头是逆序排列的，当时还好奇为什么要这么做，原因就在于这个 `next_record`。`next_record` 指向的是下一条记录的记录头和真实数据交界的位置，这个位置刚刚好，往右顺序是记录的真实数据，往左逆序是记录头，这样就可以获得一个记录的完整信息了。

### Page Directory（页目录）

如果我们想进行 point select，比如 `select * from table1 where id=1;`。

最笨的办法：从 Infimum 开始，通过 `next_record` 组成的链表进行遍历。无疑效率是低下的。

所以页目录就是用来提升这个效率的，顾名思义，它就是本页内各行记录的目录。但是，它并不是存储每一行的偏移。细节有点复杂，大概是这样：将所有行记录分成多个小组，每个组包含 1~8 条行记录，只将每个分组最后一条行记录的偏移位置按顺序记录到 Page Directory 中，称之为槽 (slot)。查找时使用二分查找。所以这是用数组加链表实现的搜索。

### Page Header

56 个字节，记录该页的元信息，比如存储了多少条记录，第一条记录的偏移地址，页目录中有多少个槽等等。

每个数据页的 File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表。

具体细节暂略。

### File Header

上一小节说的 Page Header 说的是专门针对**数据页**记录的状态信息。前面我们也说了页有多种类型，每种类型的页都有自己不同的 Page Header。而这些页通用的信息则记录在 File Header 中。不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，这个页的类型，它的上一个页、下一个页是谁。

具体细节暂略。

### File Trailer

主要是用来校验数据完整性，用来判断有没有在写磁盘中途断电等原因导致数据不完整。

## 7. 快速查询的秘籍 —— B+ 树索引

前情回顾：

> 前边我们详细唠叨了 InnoDB 数据页的 7 个组成部分，知道了各个数据页可以组成一个双向链表，而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

### 没有索引的查找

以对某列进行精确匹配进行搜索为例，即：

```
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

#### 在一个页中的查找

以主键为搜索条件：这个查找过程在前面已经描述过了，可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

以其它列作为搜索条件：因为在数据页中并没有对非主键列建立所谓的页目录，所以很显而易见，只能从头到尾进行扫表操作。效率是非常低下的。

#### 在很多页中查找

1. 定位到记录所在的页
1. 从所在页中查找记录

> 在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。

所以可见，索引对于快速查找的重要性。

### 索引

(?? 突然有个疑问，行记录中表的名字存储在哪个地方? 还是存储在页结构中?)

(仔细看完了这一章，写得真 NB，完全理解了 B+ 树索引，也完全理解了为什么建索引后查询效率能达到成百上千倍的提升。其实思想是很朴素，让每个人去设计，可能都会最终想到这种方案，人们在日常生活中不经易就在实践着这种方案。举个很简单的例子。假设每天写一篇日记，每篇日记在一个单独的文件里，写了 10 年，那么总共有 3600 个文件，如果把这些所有的日记都放在一个目录，如果我们要找某一篇日记，那天最多要查找 3600 次。为了减少查找次数，人们通过会这么做，先按年建立目录，10 个目录，按年排序，再在每个年目录中创建月目录，按月排序，再在第个月目录中，放置当月的日记，共 30 篇，按日排序，这样，查找特定某天的日记，将最多需要 `10+12+30=53` 次，而不是 `10*12*30=3600` 次，约 100 倍的提升。分级目录就是 B+ 索引。其实 Linux 的文件系统也是类似的思想。)

(以前真是太 naive，以为索引是 hash 表)

一个简单的索引方案：详细过程略，思想就是为数据页创建目录。

#### InnoDB 中的索引方案

直接看图吧：

![](../art/mysql-inside/mysql-innodb-index-1.png)

每页内部的行记录都是按主键排好序的，叶子结点的页与页之间也是有序的，组成双链表。叶子结点以上是目录结点，目录页中的行记录只记录指向的页的编号及该页中的最小主键值。

目录页中行记录的 `record_type` 为 1，而普通的记录真实数据的行记录 `record_type` 为 0。

一个目录页放不下，就会有多个目录页。

![](../art/mysql-inside/mysql-innodb-index-2.png)

如果目录页太多了，那就再创建二级目录，相当于目录的索引。

![](../art/mysql-inside/mysql-innodb-index-3.png)

最后的效果：

![](../art/mysql-inside/mysql-innodb-index-4.png)

它的名称就叫 B+ 树。

4 层的 B+ 树就能支撑 `1000×1000×1000×100=100000000000` (100 亿) 条行记录，而查找一条记录最多才需要 3100 次。索引多重要啊！

#### 聚簇索引

> 我们上边介绍的 B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
   - 页内的记录是按照主键的大小顺序排成一个单向链表。
   - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
   - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
1. B+ 树的叶子节点存储的是完整的用户记录

> 我们把具有这两种特性的 B+ 树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句），InnoDB 存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在 InnoDB 存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的`索引即数据，数据即索引`。

#### 二级索引

聚簇索引只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？

我们可以仿照聚簇索引再多建几棵 B+ 树，但采用不同的排序规则。比如以 c2 列作为排序规则：

![](../art/mysql-inside/mysql-innodb-index-5.png)

仔细观察，可以发现这个 B+ 树与聚簇索引有个最大的不同：叶子结点存储的并不是完整记录，而仅是 c2 列和主键列的值。

所以，通过 c2 列查找到叶子结点后，我们仅能拿到主键的值，然后再通过主键的值去聚簇索引中再查找一次。称之为回表。

#### 联合索引

我们可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，则排序时先按 c2 列进行排序，在 c2 列的值相同的情况下再按 c3 列进行排序。

其余和以单列排序创建的二级索引没有区别。

从上面也可以看出，一张大表的一个索引也要占据很多额外空间，也有维护成本，并且有可能影响性能，所以索引也并不是越多越好。

### InnoDB 的 B+ 树索引的注意事项

#### 根页面万年不动窝

从前面的过程，我们会以为是先有叶子结点，再有目录结点。实际过程有一点差别，实际是先有一个最初的根结点，实际数据也存储在这个根结点中，随着行记录的增多，创建新的叶子结点，将实际数据复制到叶子结点中，根结点转变成目录结点。

#### 内节点中目录项记录的唯一性

(内节点是啥?)

上面在为 c2 列创建二级索引时，说目录结点中的行记录记录的是 c2 列的值和页号，但由于 c2 列不是主键，它们可能存在相同的值，所以会带来一些问题，为了避免这些问题，在二级索引的目录页的行记录中，也会存储主键的的值。以保证其唯一性。

![](../art/mysql-inside/mysql-innodb-index-6.png)

### MyISAM 中的索引方案简单介绍

和 InnoDB 的索引方案有所区别。

MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储。

MyISAM 插入数据时，按插入顺序单独存放在一个文件中，称为数据文件。这个文件即不分页，也是按主键排序。

索引信息存储在单独的索引文件中。MyISAM 中的所有索引都是二级索引，索引中的叶子结点存储的是主键和行号，并非真实数据。先通过索引找到行号，再通过行号找到对应的记录。

具体细节略，因为目前主流存储引擎是 InnoDB。

### MySQL 中创建和删除索引的语句

> InnoDB 和 MyISAM 会自动为主键或者声明为 UNIQUE 的列去自动建立 B+ 树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。为啥不自动为每个列都建立个索引呢？别忘了，每建立一个索引都会建立一棵 B+ 树，每插入一条记录都要维护各个记录、数据页的排序关系，这是很费性能和存储空间的。

建表时创建额外索引：

```sql
CREATE TALBE 表名 (
    各种列的信息 ··· ,
    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
);
```

KEY 和 INDEX 是同义词，任选其一就行。

修改表结构时添加索引：

```sql
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);
```

删除索引：

```sql
ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;
```

示例：

```sql
CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1),
    INDEX idx_c2_c3 (c2, c3)
);
```

## 8. 好东西也得先学会怎么用 —— B+ 树索引的使用

这一章主要讲的是如何利用好创建的索引，如果写的查询语句不够准确，就有可能用不上索引，而需要扫表，导致查询效率成百上千倍地下降。

### 索引的代价

索引虽然是好东西，但也不能随便建，需要的才建。因为它在空间和时间上都有代价。

- 空间代价：显而易见，每建一个索引就会生成一棵 B+ 树，一棵 B+ 树的存储空间也不小。
- 时间代价：每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。

所以一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

### B+ 树索引适用的条件

以例子来说明，假设有这么一张表：

```
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

这张表的主键是 id，InnoDB 会为它自动创建聚簇索引。另外，我们还定义了一个二级联合索引 `idx_name_birthday_phone_number`，这个二级索引会依次按 name, birthday, phone number 进行排序，这个排序非常重要，后面所有的查询都要依赖这个排序。

- 先按照 name 列的值进行排序
- 如果 name 列的值相同，则按照 birthday 列的值进行排序
- 如果 birthday 列的值也相同，则按照 phone_number 的值进行排序

### 用于匹配 (where)

#### 全值匹配

```
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

很显而易见，这样写可以准确命中索引。name/birthday/phonenumber 三者的顺序可以调换，没有影响，这是因为 MySQL 有一个查询优化器的东西可以将查询进行优化。

#### 匹配左边的列

搜索语句可以不需要包含全部联合索引中的列，但至少要包含从左边开始的列，比如 name 或者 name,birthday，其它情况则无法用上此二级索引，比如 birthday / phonenumber / name,phonenumber / birthday,phonenumber。(很好理解)

但是 name,phonenumber 虽然用不上这个完整的二级索引，但可以用上此二级索引中按 name 进行排序的部分索引。

示例，可以用上完整的索引：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn';
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
```

只能用上 name 列的索引：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';
```

用不上索引：

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```

#### 匹配列前缀

```sql
SELECT * FROM person_info WHERE name LIKE 'As%';
SELECT * FROM person_info WHERE name LIKE '%As%';
```

上面第一条语句可以用上 name 列的索引，但第二条就用不上了，只能全表扫描。(完全理解，可见，就一个细微的差别，查询效率就是成百上千倍的区别。)

#### 匹配范围值

> 如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引。

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```

上例都只能用到 name 列的索引。

#### 精确匹配某一列并范围匹配另外一列

> 对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找。

比如下例可以用到 name,birthday 列的索引，但用不到 name,birthday,phone_number 列索引。

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

下例则可以用到完整的 name,birthday,phone_number 联合索引。

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1980-01-01' AND phone_number > '15100000000';
```

### 用于排序 (order by)

在 MySQL 中，把在内存中或者磁盘上进行排序的方式统称为文件排序 (filesort)。

如果 `order by` 用上了索引列，则有可能省去在内存或文件中排序的步骤。比如：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

使用联合索引进行排序注意事项：`order by` 后面列的顺序必须和索引中列的顺序一致，如果是 `ORDER BY phone_number, birthday, name` 就用不了前面定义的索引。

同理，`ORDER BY name`、`ORDER BY name, birthday` 这种匹配索引左边的列的形式可以使用部分的 B+ 树索引。

当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如 `SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;`。

#### 不可以使用索引进行排序的几种情况

1. ASC, DESC 混用

   很好理解。

   `ORDER BY name, birthday LIMIT 10`，这种情况直接从索引的最左边开始往右读 10 行记录就可以了。

   `ORDER BY name DESC, birthday DESC LIMIT 10`，这种情况直接从索引的最右边开始往左读 10 行记录就可以了。

   但混用，就比较麻烦，还不如直接用文件排序。

1. WHERE 子句中出现非排序使用到的索引列

   比如：`SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;`

1. 排序列包含非同一个索引的列

   比如：`SELECT * FROM person_info ORDER BY name, country LIMIT 10;`

1. 排序列使用了复杂的表达式

   比如使用了 upper() 函数：`SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;`

### 用于分组 (group by)

示例：

```sql
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number;
```

注意事项和前面差不多，都是只能匹配索引包含左边的列。

### 回表的代价

示例：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

上面这条 sql，先通过二级索引，找到相应的叶子结点记录，这些叶子结点记录是连续的 (称之为`顺序 I/O`)，但它们保存的并不是完整记录，只是 id 加上索引列的值，所以还需要通过 id 再去聚簇索引查找相应的完整记录，即回表，但是这些 id 值可能并不是连续的，因此在聚簇索引中找到的叶子结点也是分散的，可能分布在不同的数据页，这样读取完整记录可能要访问更多的数据页，这种读取方式称之为`随机 I/O`。

需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用二级索引。比方说 name 值在 Asa ～ Barlow 之间的用户记录数量占全部记录数量 90% 以上，那么如果使用 `idx_name_birthday_phone_number` 索引的话，有 90% 多的 id 值需要回表，还不如直接去扫描聚簇索引（也就是全表扫描）。

何时用全表扫描，何时用二级索引 + 回表，由查询优化器来决定。

查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式。

使用 `limit` 会让查询优化器倾向于使用二级索引 + 回表的方式，比如：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;
```

而这个例子：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number;
```

虽然能用上索引，但由于 select 的是 `*`，回表操作代价较大，所以优化器倾向使用全表扫描。但如果加上了 `limit 10`，回表代价较小，就倾向用二级索引 + 回表。

#### 覆盖索引

为了避免回表，建议：**最好在查询列表里只包含索引列**，比如：

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

上面的语句通过 `idx_name_birthday_phone_number` 二级索引就能拿到所有的值，不需要回表。这种只需要用到索引的查询方式称为索引覆盖。

### 如何挑选索引

上面说了这么多索引的使用注意事项及索引的代价，所以在建索引时要比较小心。

#### 只为用于搜索、排序或分组的列创建索引

只为出现在 where/order by/group by 子句中的列创建索引。比如：

```sql
SELECT birthday, country FROM person_name WHERE name = 'Ashburn';
```

只需要为 name 建索引，birthday 和 country 就不需要了。

#### 考虑列的基数

其实是说，如果某列各行的值，如果重复的太多，即基数小，则建索引意义不大；重复的很少，即基数大，才更有意义。

#### 索引列的类型尽量小

比如能用 int 类型就不要用 bigint 类型。

#### 索引字符串值的前缀

如果字符很长，则索引要占的空间越大，可以只对字符的前几个字符，比如前 10 个字符建索引。

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);
```

这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。

影响：但是上面这种索引只能用于 where 查询，如果是 order/by 就不能用上索引，比如：

```sql
SELECT * FROM person_info ORDER BY name LIMIT 10;
```

#### 让索引列在比较表达式中单独出现

比较两个查询：

- `where mycol * 2 < 4`
- `where mycol < 4/2`

前者不能用上 mycol 索引，而后者可以。

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

#### 主键插入顺序

如果插入的主键值忽大忽小，就会比较麻烦，造成数据页的分裂和位移，影响性能。

建议：让主键具有 `AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入。

#### 冗余和重复索引

```sql
CREATE TABLE person_info(
    ...
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
    KEY idx_name (name(10)),

    UNIQUE uidx_c1 (c1),
    INDEX idx_c1 (c1)
);
```

`idx_name_birthday_phone_number` 索引其实已经包含了 `idx_name` 索引，所以 `idx_name` 是多余的。

`UNIQUE` 列会自动创建索引，无须再手动创建。

(话说，优化器不会自动优化的吗？)

### 总结

1. B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引

1. B+ 树索引适用于下边这些情况：

   - 全值匹配
   - 匹配左边的列
   - 匹配范围值
   - 精确匹配某一列并范围匹配另外一列
   - 用于排序
   - 用于分组

1. 在使用索引时需要注意下边这些事项：

   - 只为用于搜索、排序或分组的列创建索引
   - 为列的基数大的列创建索引
   - 索引列的类型尽量小
   - 可以只对字符串值的前缀建立索引
   - 只有索引列在比较表达式中单独出现才可以适用索引
   - 为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有 `AUTO_INCREMENT` 属性
   - 定位并删除表中的重复和冗余索引
   - 尽量使用覆盖索引进行查询，避免回表带来的性能损耗

(这一章内容好多，分三天才看完，完全理解了。目前为止觉得是写得最好的一本小册了。)

## 9. 数据的家 —— MySQL 的数据目录

InnoDB 这些存储引擎最终是将数据以文件的形式存储在磁盘上，即文件系统上。本小节来看看数据是如何在文件系统上存储的，说白了就是有哪些文件。

### MySQL 数据目录

查看数据目录：`SHOW VARIABLES LIKE 'datadir'`，默认是 `/usr/local/var/mysql/`。

查看数据目录下都有哪些文件，除了一些系统文件外，每个数据库都有一个单独目录，在目录中每个表有一个单独的文件 (也有可能多个)。

(似乎我 mac 上的文件和教程上的不太一样...教程里说，每个表的表结构也会以一个单独的文件存在，比如 test 库里的 user 表，则有 `test/user.frm` 文件，但在我 mac 上并没有发现 .frm 的文件。哦哦，后面看到解释了，跟 MySQL 版本有关系)

#### InnoDB 是如何存储表数据的

- 系统表空间 - ibdata1
- 独立表空间
- 其它类型的表空间 - 通用表空间（general tablespace）、undo 表空间（undo tablespace）、临时表空间（temporary tablespace）...

系统表空间，没太理解，大致是说会创建一个 ibdata1 的文件，所有表的数据都放到这个文件里，当容量不够时会自动扩张 (我想是依次生成 ibdata2, ibdata3 等文件吧)。

独立表空间，是 MySQL 5.6.6 之后的方案，就是上面说的，为每个表都单独创建文件，后缀为 `.ibd`。

可以指定使用系统表还是独立表空间，具体配置略。

#### MyISAM 是如何存储表数据的

MyISAM 没有表空间一说，就是每个表存到单独文件里，而且索引和数据是分开存储的，索引后缀为 `.MYI`，数据后缀为 `.MYD`。

#### 视图在文件系统中的表示

视图是虚拟表，数据只在内存中，不需要落盘，因为没有数据文件，但有表结构文件，即 `.frm` 文件。(我 mac 上没有看到任何 `.frm` 文件)

#### 其他的文件

- 服务器进程文件 - 启动 MySQL 服务端后，MySQL 服务器会把自己的进程 ID 写入到一个文件中 (Linux 常规操作)
- 服务器日志文件 - 各种日志
- 默认/自动生成的 SSL 和 RSA 证书和密钥文件

### 文件系统对数据库的影响

- 数据库名称和表名称不得超过文件系统所允许的最大长度
- 特殊字符的问题 (详略，比如表名 `test?` 会转换成 `test@003f`)
- 文件长度受文件系统最大长度限制

### MySQL 系统数据库简介

- mysql - 存储了 MySQL 的用户账户和权限信息等重要信息
- information_schema - 这个数据库保存着 MySQL 服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引等元信息
- performance_schema - 这个数据库里主要保存 MySQL 服务器运行过程中的一些状态信息，算是对 MySQL 服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息
- sys - 这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解 MySQL 服务器的一些性能信息

(soga)

## 10. 存放页面的大池子 —— InnoDB 的表空间

(这一小节有点长，概念很多，分两三天看完吧，先有个大概认识就行，具体细节需要时再深入理解)

上一小节讲到了 InnoDB 的系统表空间和独立表空间。可以把表空间想像成 "页" 的池子，里面切分成了很多很多页。

### 回忆一些旧知识

#### 页面类型

InnoDB 是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以 B+ 树的形式保存到表空间的，而 B+ 树的节点就是数据页。

除了数据页外，还有其它若干种类型的页。(具体的类型详略)

#### 页面通用部分

每个页都有相同的 File Header 和 File Trailer 结构，中间部分则不同类型的页有不同的定义。

![](../art/mysql-inside/mysql-innodb-page.png)

- File Header：记录页面的一些通用信息
- File Trailer：校验页是否完整，保证从内存到磁盘刷新时内容的一致性。

File Header 的具体格式详略。(需要时再查)

表空间中的每一个页都对应着一个页号，也就是 File Header 中的 `FIL_PAGE_OFFSET`，这个页号由 4 个字节组成，也就是 32 个比特位，所以一个表空间最多可以拥有 2^32 个页，如果按照页的默认大小 16KB 来算，一个表空间最多支持 64TB 的数据。

### 独立表空间结构

先看简单一点的独立表空间，再看复杂一点的系统表空间。

先放一张在文章最后才出现的表空间全景图：

![](../art/mysql-inside/mysql-innodb-table-space.png)

#### 区 (extent) 的概念

对于 16KB 的页来说，连续的 64 个页就是一个区，也就是说一个区默认占用 1MB 空间大小。

每 256 个区被划分成一组。extent 0 ~ extent 255 这 256 个区算是第一个组，extent 256 ~ extent 511 这 256 个区算是第二个组，extent 512 ~ extent 767 这 256 个区算是第三个组，依此类推。

![](../art/mysql-inside/mysql-innodb-extent.png)

从上图可以看出：

1. 第一个组最开始的 3 个页面的类型是固定的，也就是说 extent 0 这个区最开始的 3 个页面的类型是固定的，分别是：

   - `FSP_HDR` 类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区，也就是 extent 0 ~ extent 255 这 256 个区的属性，稍后详细唠叨。需要注意的一点是，整个表空间只有一个 `FSP_HDR` 类型的页面。
   - `IBUF_BITMAP` 类型：这个类型的页面是存储本组所有的区的所有页面关于 INSERT BUFFER 的信息 (后面细说)
   - INODE 类型：这个类型的页面存储了许多称为 INODE 的数据结构 (后面细说)

1. 其余各组最开始的 2 个页面的类型是固定的，也就是说 extent 256、extent 512 这些区最开始的 2 个页面的类型是固定的，分别是：

   - XDES 类型：全称是 extent descriptor，用来登记本组 256 个区的属性...
   - `IBUF_BITMAP` 类型

#### 段 (segment) 的概念

说段之前，说说为什么已经有页了，为啥还要有 "区" 的概念...(详略)，大致总结就是为了提前存储和查询效率，比如对于 B+ 树来说，叶子结点组成了双链表，那它们最好存储在相邻的地方，而目录结点也组成了双链表，目录结点也最好存储在相邻页。有了区的概念后，所有页子结点可以放在同一个或多个区里，而所有目录结点放在另外的区里...分配空间时，可以按区来分配，一次性分配一个区的空间，一个区里有 64 个连续的页...

...也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成 2 个段，一个叶子节点段，一个非叶子节点段。

所以，段是不同功能的区的集合...

但是，为了在存储较小的表时不浪费空间，又提出了一个碎片 (fragment) 区的概念...(这一部分有点没太理解)

...在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段 A，有些页用于段 B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。

为某个段分配存储空间的策略是这样的：

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了 32 个碎片区页面之后，就会以完整的区为单位来分配存储空间。

#### 区的分类

也称为区的 4 种状态：

| 状态名    | 含义                 |
| --------- | -------------------- |
| FREE      | 空闲的区             |
| FREE_FRAG | 有剩余空间的碎片区   |
| FULL_FRAG | 没有剩余空间的碎片区 |
| FSEG      | 附属于某个段的区     |

#### XDES Entry 链表

为了方便管理这些区，InnoDB 设计了一个称为 XDES Entry 的结构（全称就是 Extent Descriptor Entry），每一个区都对应着一个 XDES Entry 结构，它们会组成双链表...(详情先暂时略过)

...搞出这么多概念的初心是提高向表插入数据的效率又不至于数据量少的表浪费空间。

小结：...

#### 段的结构

像每个区都有对应的 XDES Entry 来记录这个区中的属性一样，InnoDB 为每个段都定义了一个 INODE Entry 结构来记录一下段中的属性...(详略)

后面大篇幅都是介绍各种结构，先暂时跳过...

### 系统表空间

和独立表空间结构大致一样，多了一些额外信息，详略。

#### InnoDB 数据字典

MySQL 除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：

- 某个表属于哪个表空间，表里边有多少列
- 表对应的每一个列的类型是什么
- 该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面
- 该表有哪些外键，外键对应哪个表的哪些列
- 某个表空间对应文件系统上文件路径是什么
- ...

这些数据称之为元数据，InnoDB 存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些元数据...

这些系统表也被称为数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中 `SYS_TABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS` 这四个表尤其重要，称之为基本系统表（basic system tables）...

这些表都有哪些列...(略)

##### Data Dictionary Header 页面

只要有了上述 4 个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据...

也就是说这 4 个表是表中之表，那这 4 个表的元数据去哪里获取呢？没法搞了，只能把这 4 个表的元数据，就是它们有哪些列、哪些索引等信息硬编码到代码中，然后 InnoDB 又拿出一个固定的页面来记录这 4 个表的聚簇索引和二级索引对应的 B+ 树位置，这个页面就是页号为 7 的页面，类型为 SYS，记录了 Data Dictionary Header，也就是数据字典的头部信息...

(理解，就好比是电脑的 bootloader)

Data Dictionary Header 的详细结构...(略)

#### information_schema 系统数据库

用户是不能直接访问 InnoDB 的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过 InnoDB 考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 `information_schema` 中提供了一些以 `innodb_sys` 开头的表...

```
mysql> USE information_schema;
Database changed

mysql> SHOW TABLES LIKE 'innodb_sys%';
+--------------------------------------------+
| Tables_in_information_schema (innodb_sys%) |
+--------------------------------------------+
| INNODB_SYS_DATAFILES                       |
| INNODB_SYS_VIRTUAL                         |
| INNODB_SYS_INDEXES                         |
| INNODB_SYS_TABLES                          |
| INNODB_SYS_FIELDS                          |
| INNODB_SYS_TABLESPACES                     |
| INNODB_SYS_FOREIGN_COLS                    |
| INNODB_SYS_COLUMNS                         |
| INNODB_SYS_FOREIGN                         |
| INNODB_SYS_TABLESTATS                      |
+--------------------------------------------+
10 rows in set (0.00 sec)
```

(这些表实际是视图吧...)

最终总结：

![](../art/mysql-inside/mysql-innodb-table-space.png)

(这一章先粗略地过吧)

## 11. 条条大路通罗马 —— 单表访问方法

单表查询：就是只从一个表里查询，没有 join 操作。

本小节所用的示例表：

```sql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

本表有 1 个聚簇索引和 4 个二级索引，分别的：

- 为 id 列建立的聚簇索引。
- 为 key1 列建立的 idx_key1 二级索引。
- 为 key2 列建立的 idx_key2 二级索引，而且该索引是唯一二级索引。
- 为 key3 列建立的 idx_key3 二级索引。
- 为 key_part1、key_part2、key_part3 列建立的 idx_key_part 二级索引，这也是一个联合索引。

### 访问方法（access method）的概念

查询的执行方式大致分以下几种：

- 使用全表扫描
- 使用索引
  - 针对主键或唯一二级索引的等值查询
  - 针对普通二级索引的等值查询
  - 针对索引列的范围查询
  - 直接扫描整个索引

把 MySQL 执行查询语句的方式称之为**访问方法**或者**访问类型**。同一个查询语句可能可以使用多种不同的访问方法来执行。

访问方法的具体内容：

- const
- ref
- ref_or_null
- range
- index
- all

#### const

通过主键列来定位一条记录，或者通过唯一二级索引来定位一条记录，比如：

```sql
SELECT * FROM single_table WHERE id = 1438;
SELECT * FROM single_table WHERE key2 = 3841;
```

这种查询的复杂度是常数级别 O(n)，非常快，所以称之为 const 访问方法。

不过这种 const 访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个 const 访问方法才有效。

对于唯一二级索引来说，查询该列为 NULL 值的情况比较特殊，比如：

```sql
SELECT * FROM single_table WHERE key2 IS NULL;
```

因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用 const 访问方法来执行。

#### ref

对某个普通的二级索引列 (非唯一二级索引，说明此列允许有重复值) 与常数进行等值比较：

```sql
SELECT * FROM single_table WHERE key1 = 'abc';
```

如果匹配到的记录较少，则回表代价低，性能只比 const 低一丢丢。这种称之为 ref 访问方法。

不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含 NULL 值的数量并不限制，所以我们采用 key IS NULL 这种形式的搜索条件最多只能使用 ref 的访问方法，而不是 const 的访问方法。

#### ref_or_null

对二级索引列进行等值比较，且包含 NULL 记录时：

```sql
SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;
```

当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为 ref_or_null。

#### range

使用索引进行范围匹配：

```sql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```

#### index

(就不能换个具体点的名字吗? 都这么多 index 了...)

```sql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

key_part1, key_part2, key_part3 是联合索引，但搜索条件 key_part2 不是联合索引的最左边列。

可以通过在 key_part1, key_part2, key_part3 联合索引的 B+ 树结点中通过扫描对比找到 key_part2='abc' 的那个节点，然后直接从节点上把这三列的值取到，不需要回表。这种方式称为之 index。

#### all

即全表扫描。

### 注意事项

(先了解个大概就行...)

#### 重温二级索引 + 回表

一般情况下，只能利用单个二级索引执行行查询 (那后面自然有特殊情况喽)，比如：

```sql
SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
```

因为等值比较一般比范围比较命中的记录少，所以查询优化器先通过 `key='abc'` 条件使用 ref 方法在 idx_key1 索引树中找匹配的 id 记录，然后回表，再通过 `key2 > 1000` 的条件进行过滤。

#### 明确 range 访问方法使用的范围区间

对于 B+ 树索引来说，只要索引列和常数使用 =、<=>、IN、NOT IN、IS NULL、IS NOT NULL、>、<、>=、<=、BETWEEN、!=（不等于也可以写成<>）或者 LIKE 操作符连接起来，就可以产生一个所谓的区间。

**所有搜索条件都可以使用某个索引的情况**

```sql
SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200; // 实际等于 WHERE key2 > 200
SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200;  // 实际等于 WHERE key2 > 100
```

**有的搜索条件无法使用索引的情况**

```sql
SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc';
```

把用不到的替换成 TRUE，则上面变成：

```sql
SELECT * FROM single_table WHERE key2 > 100 AND TRUE;
```

则对 key2 使用 range 方式查询，范围为 `>100`

如果是 OR 也一样：

```sql
SELECT * FROM single_table WHERE key2 > 100 OR common_field = 'abc';
```

化简后变成：

```sql
==> SELECT * FROM single_table WHERE key2 > 100 OR TRUE;
==> SELECT * FROM single_table WHERE TRUE;
```

这说明如果强制使用 key2 索引列进行查询，那范围是所有，还不如全表查询。也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用 OR 连接起来后是无法使用该索引的。

**复杂搜索条件下找出范围匹配的区间**

略。

#### 索引合并

一般情况下查询时只能用到一个二级索引，特殊情况下可以用到多个，这种执行方法称之为 index merge，有三种合并算法：

- Intersection 合并
- Union 合并
- Sort-Union 合并

**Intersection 合并**

示例：

```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
```

分别通过 idx_key1 二级索引找到对应记录的 id，通过 idx_key3 找到对应记录的 id，取两者 id 的**交集**，再回表找完整记录。总共查找三次索引树。

当然，如果 `key1='a'` 和 `key3='b'` 匹配的记录过多，那优化器也会用其它办法。这些情况都不是绝对的。

**Union 合并**

```sql
SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b';
```

分别通过 idx_key1 二级索引找到对应记录的 id，通过 idx_key3 找到对应记录的 id，取两者 id 的**并集**，再回表找完整记录。总共查找三次索引树。

**Sort Union 合并**

Union 索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到 Union 索引合并：

```sql
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z';
```

但可以这样做：

- 先根据 `key1 < 'a'` 条件从 idx_key1 二级索引中获取记录，并按照记录的主键值进行排序
- 再根据 `key3 > 'z'` 条件从 idx_key3 二级索引中获取记录，并按照记录的主键值进行排序
- 因为上述的两个二级索引主键值都是排好序的，剩下的操作和 Union 索引合并方式就一样了

## 12. 两个表的亲密接触 —— 连接的原理

(这一章也写得很好，终于搞明白了内连接，外连接，左连接，右连接)

即 join 操作。

### 连接介绍

连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。

结果集可以称之为笛卡尔积。

如果 t1 表有 4 行记录，t2 表有 5 行记录，在不加任何过滤条件的情况下，产生的结果集为 `4*5=20` 条记录。即拿 t1 表的每一条记录都和 t2 的 5 条记录进行组合 (但这样做一般没有意义)。

对应的 SQL 语句可以这么写：`select * from t1, t2;`。

### 连接过程简介

```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

三个过滤条件：

- `t1.m1 > 1`
- `t1.m1 = t2.m2`
- `t2.n2 < 'd'`

执行过程：

1. 首先确定第一个需要查询的表，这个表称之为**驱动表**。本例中使用 t1 作为驱动表，根据 `t1.m1 > 1` 过滤条件得到相应的结果，因为没有没有给 t1 表建索引，所以 t1 表采用全表扫描查询。比如从 t1 得到符合条件的记录为 2 条。
1. 用从 t1 得到的记录集合中的每一条记录，加上 `t1.m1 = t2.m2` 和 `t2.n2 < 'd'` 的条件，得 t2 表的所有记录进行匹酷。因为从 t1 得到 2 条记录，所以 t2 要被全表扫描两次。

所以，最终上面这个两表连接查询共需要查询 1 次 t1 表，2 次 t2 表。...也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。

### 内连接和外连接

(例子略)

一般情况下，如果驱动表的记录，在被驱动表中没有记录和它匹配，那么驱动表中的这些记录不会被加入到记录集中。这种称之为内连接。

如果需要驱动表中的记录，无论在被驱动表中有无记录和它区配，驱动表中的记录都要加入到记录集中。这种称之为外连接。

(我想是不是外连接一般用在需要进行统计的情况下，需要对结果集进行聚合统计，比如 `count(*)` 之类)

对于外连接来说，根据选择的驱动表的不同，又分：

- 左连接：选取左侧的表为驱动表
- 右连接：选取右侧的表为驱动表

但，对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。这就犯难了，有时候匹配失败要加入结果集，有时候又不要加入结果集...解决办法就是把过滤条件分为两种，分别是 WHERE 和 ON。

- WHERE 子句
- ON 子句：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充。

对于内连接来说，ON 和 WHERE 其实是等价的。

一般情况下，我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中，我们也一般把放到 ON 子句中的过滤条件也称之为连接条件。

所以前面的例子实际一般写成：

```sql
// 原来的写法
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';

// 更常见的写法
SELECT * FROM t1 JOIN t2 ON t1.m1 = t2.m2 WHERE t1.m1 > 1 AND t2.n2 < 'd';
              ~~~~~~~~~~
```

上面 FROM 后面的对象是 `(t1 JOIN t2)` 整体，并不只是 t1。

### 左（外）连接的语法

```sql
SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
              ~~~~~~~~~~~~~~~~~~~~~~~
```

`[OUTER]` 可以省略，`LEFT` 表示在连接，在 `t1 JOIN t2` 中选择左边的 t1 作为驱动表。

示例：

```
mysql> SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score AS s2 ON s1.number = s2.number;
+----------+-----------+-----------------------------+-------+
| number   | name      | subject                     | score |
+----------+-----------+-----------------------------+-------+
| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |
| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |
| 20180102 | 范统      | 母猪的产后护理              |   100 |
| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |
| 20180103 | 史珍香    | NULL                        |  NULL |
+----------+-----------+-----------------------------+-------+
5 rows in set (0.00 sec)
```

### 右（外）连接的语法

```sql
SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
              ~~~~~~~~~~~~~~~~~~~~~~~~
```

`RIGHT` 表示从 `t1 JOIN t2` 中选择右边的 t2 作为驱动表。

### 内连接的语法

```sql
SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];
```

下面四种写法是等价的：

- `SELECT * FROM t1 JOIN t2;`
- `SELECT * FROM t1 INNER JOIN t2;`
- `SELECT * FROM t1 CROSS JOIN t2;`
- `SELECT * FROM t1, t2;`

推荐使用第二种写法。

由于在内连接中 ON 子句和 WHERE 子句是等价的，所以内连接中不要求强制写明 ON 子句。

对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。

### 连接的原理

#### 嵌套循环连接（Nested-Loop Join）

...这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join），这是最简单，也是最笨拙的一种连接查询算法。

#### 使用索引加快连接速度

在嵌套循环连接中，对被驱动表是进行全表扫描，但如果被驱动表有相应索引的话，是可以利用上索引进行查询的。

#### 基于块的嵌套循环连接（Block Nested-Loop Join）

为了减少被驱动表的访问次数... join buffer。

join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。

最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。这种算法称之为基于块的嵌套连接（Block Nested-Loop Join）算法。

这个 join buffer 的大小是可以通过启动参数或者系统变量 join_buffer_size 进行配置...

另外，尽量不要直接 `select *`，而是只 select 想要的列，这样可以让 join buffer 尽量放下更多的记录。

## 13. 谁最便宜就选谁 —— MySQL 基于成本的优化

(这一章先简单了解)

- I/O 成本：把数据从磁盘到内存这个加载的过程损耗的时间称之为 I/O 成本。
- CPU 成本：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本。

MySQL 规定，读取一个页面花费的成本默认是 1.0，读取以及检测一条记录是否符合搜索条件的成本默认是 0.2。1.0、0.2 这些数字称之为成本常数。

### 单表查询的成本

(具体过程先理解即可)

示例表：略。

**基于成本的优化步骤**

- 根据搜索条件，找出所有可能使用的索引
- 计算全表扫描的代价
- 计算使用不同索引执行查询的代价
- 对比各种执行方案的代价，找出成本最低的那一个

每种方案的代价是 I/O 成本和 CPU 成本之和。

计算成本时所需的信息，比如该表记录行数 (不完全精确)，所占页面的总大小，MySQL 为每个表维护了一系列的统计信息，可以使用 `select table status like 'table_name'` 查看。

案例分析：暂略。

**基于索引统计数据的成本计算**

(稍候补充) index dive

### 连接查询的成本

它的查询成本由下边两个部分构成：

- 单次查询驱动表的成本
- 多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）

我们把对驱动表进行查询后得到的记录条数称之为驱动表的扇出（英文名：fanout）。

(soga，原来扇出是这个意思。)

扇出值越小，成本越低，所以要先计算 (猜) 出驱动表的扇出值。

### 两表连接的成本分析

连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本

对于外连接来说，驱动表和被驱动表是固定的。但对于内连接来说，驱动表和被驱动表是可以互换的，因此计算成本复杂此。

- 尽量减少驱动表的扇出
- 对被驱动表的访问成本尽量低

### 多表连接的成本分析

暂略。

### 调节成本常数

除了 1.0 和 0.2 两个成本常数外，还有很多其它常数，存储在 mysql 系统数据库。

```
mysql> SHOW TABLES FROM mysql LIKE '%cost%';
+--------------------------+
| Tables_in_mysql (%cost%) |
+--------------------------+
| engine_cost              |
| server_cost              |
+--------------------------+
2 rows in set (0.00 sec)
```

表的详细解读，先略过。

## 14. 兵马未动，粮草先行 —— InnoDB 统计数据是如何收集的

(简单了解)

### 两种不同的统计数据存储方式

内存或磁盘。

InnoDB 默认是以表为单位来收集和存储统计数据的。不同的表可以按不同的方式存储统计数据。

```sql
CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);
ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);
```

1 表示硬盘，0 表示内存，如果没有指定则用系统变量 `innodb_stats_persistent` 值。

### 基于磁盘的永久性统计数据

统计数据会被存储在两个 mysql 数据库的表中。

```
mysql> SHOW TABLES FROM mysql LIKE 'innodb%';
+---------------------------+
| Tables_in_mysql (innodb%) |
+---------------------------+
| innodb_index_stats        |
| innodb_table_stats        |
+---------------------------+
2 rows in set (0.01 sec)
```

- `innodb_table_stats` 存储了关于表的统计数据，每一条记录对应着一个表的统计数据
- `innodb_index_stats` 存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据

`innodb_table_stats` 的统计数据包括各表的 row 总数 (非精确)，聚簇索引占的页面数，其它索引占的页面数。

这些数据是如何收集的，通过表空间结构，细节暂略。

`innodb_index_stats`，主要的列：

- stat_name - 统计项的名称
- stat_value - 对应的统计项的值
- sample_size - 为生成统计数据而采样的页面数量
- stat_description - 对应的统计项的描述

stat_name 表示各种统计项：

- `n_leaf_pages` - 表示该索引的叶子节点占用多少页面
- size - 表示该索引共占用多少页面
- `n_diff_pfxNN` - 表示对应的索引列不重复的值有多少

### 定期更新统计数据

两种方式：

- 自动，开启 `innodb_stats_auto_recalc` 为 ON，异步
- 手动，调用 `ANALYZE TABLE xxx`，同步 (会影响业务)

还可以手动更新 `innodb_table_stats` 和 `innodb_index_stats` 表，然后调用 `FLUSH TABLE xxx` 让 MySQL 查询优化器重新加载我们更改过的数据。

### 基于内存的非永久性统计数据

已经不常用，略过。

### innodb_stats_method 的使用

(innodb_stats_method 后面会解释，是用来处理索引列 NULL 值问题)

**索引列不重复的值的数量**这个统计数据对于 MySQL 查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行。

但计算这个值时比较烦人的是如果索引列出现 NULL 怎么办。比如：

```
+------+
| col  |
+------+
|    1 |
|    2 |
| NULL |
| NULL |
+------+
```

对于如何理解 NULL 值，有几种分歧：

1. NULL 代表一个未确定的值，MySQL 规定任何和 NULL 做比较的表达式的值都是 NULL。

   比如 `select 1 = NULL;`, `select 1 != NULL;`, `select NULL = NULL;`, `select NULL != NULL;` 返回值都是 NULL，而不是 boolean 值。(哦...原来如此，难怪之前在写 where 语句时，不能直接对 NULL 进行比较，而是要用 `IS NULL` 或 `NOT NULL` 这种写法)。

   所以每一个 NULL 值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把 NULL 值当作一个独立的值，所以 col 列的不重复的值的数量就是：4（分别是 1、2、NULL、NULL 这四个值）。

1. 认为所有 NULL 代表的意义是一样的，所以 col 列不重复的值的数量是 3 (1，2，NULL)

1. 认为 NULL 没有意义，所以 col 列不重复的值的数量是 2

针对上面三种处理办法，MySQL 提供了 `innodb_stats_method` 系统变量。有三个值：

- `nulls_equal` - 认为所有 NULL 是相等的，默认值
- `nulls_unequal` - 认为所有 NULL 都是不相等的
- `nulls_ignored` - 忽略 NULL

(把选择权交给了用户...)，结论就是**最好不在索引列中存放 NULL 值才是正解**。

## 15. 不好看就要多整容 —— MySQL 基于规则的优化（内含关于子查询优化二三事儿）

前面我们说了这么多规则，如果要求每个开发人员都深刻地理解并掌握，那是不可能的。免不了一些人写出执行起来十分耗费性能的语句。MySQL 在内部会尽量去帮你优化查询语句，根据一些规则，转换成更高效的语句，这个过程称为**查询重写**。

本章讲的这是依据的这些重写规则。

### 条件化简

MySQL 的查询优化器会简化复杂的表达式。

#### 移除不必要的括号

```sql
((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
-->
(a = 5 and b = c) OR (a > c AND c < 5)
```

#### 常量传递（constant_propagation）

```sql
a = 5 AND b > a
-->
a = 5 AND b > 5
```

#### 等值传递（equality_propagation）

```sql
a = b and b = c and c = 5
-->
a = 5 and b = 5 and c = 5
```

#### 移除没用的条件（trivial_condition_removal）

对于一些明显永远为 TRUE 或者 FALSE 的表达式，优化器会移除掉它们。

```sql
(a < 1 and b = b) OR (a = 6 OR 5 != 5)
-->
(a < 1 and TRUE) OR (a = 6 OR FALSE)
-->
a < 1 OR a = 6
```

#### 表达式计算

```sql
a = 5 + 1
-->
a = 6
```

但像 `ABS(a)>5`，`-a < -8` 这种，优化器不会尝试进行化简。

#### HAVING 子句和 WHERE 子句的合并

如果查询语句中没有出现诸如 SUM、MAX 等等的聚集函数以及 GROUP BY 子句，优化器就把 HAVING 子句和 WHERE 子句合并起来。(soga)

#### 常量表检测

(暂时不是很理解)

使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表，这种方式查询花费的时间特别少...把这种方式查询的表称之为**常量表**(constant tables)。

优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。比如：

```sql
SELECT * FROM table1 INNER JOIN table2
    ON table1.column1 = table2.column2
    WHERE table1.primary_key = 1;
```

这个查询可以使用主键和常量值的等值匹配来查询 table1 表，也就是在这个查询中 table1 表相当于常量表，在分析对 table2 表的查询成本之前，就会执行对 table1 表的查询，并把查询中涉及 table1 表的条件都替换掉。

```sql
SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2
    ON table1表column1列的常量值 = table2.column2;
```

### 外连接消除

(总结就是说，有些 SQL 语句看着是外连接，实际可以转换成内连接。)

因为内连接驱动表和被驱动表可以互换，所以可能可以通过驱地表和被驱动表互换来达到优化；而外连接驱动表和被驱动表是固定的，无法享受这种优化可能性。

所以如果某种情况下，外连接可以转换成内连接的话，就能增加优化的可能性。

那什么情况下外连接可以转换成内连接呢？对于外连接来说，如果驱动表中的记录无法在被驱动表中找到匹配 ON 子句中的过滤条件的话，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充。

比如下例：

```sql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
|    1 | a    | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)
```

这时，如果你在查询语句中同时指定了 t2 表的列不为 NULL，即 `where t2.m2 IS NOT NULL`，比如：

```sql
mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.01 sec)
```

那么这本质上是一个内连接！

我们把这种在外连接查询中，指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称之为空值拒绝（英文名：reject-NULL）。在被驱动表的 WHERE 子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

(什么时候会在外连接中又同时指定被驱动表中的列不为 NULL，本质上这就是一种错误写法嘛，只不过优化器帮你纠正了)

### 子查询优化

#### 子查询语法

查询可以嵌套，被嵌套的查询称之为子查询，它可以出现在外层查询的各种位置。

- SELECT 子句中

  ```sql
   mysql> SELECT (SELECT m1 FROM t1 LIMIT 1);
   +-----------------------------+
   | (SELECT m1 FROM t1 LIMIT 1) |
   +-----------------------------+
   |                           1 |
   +-----------------------------+
   1 row in set (0.00 sec)
  ```

- FROM 子句中

  ```sql
  mysql> SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2) AS t;
  +------+------+
  | m    | n    |
  +------+------+
  |    4 | c    |
  |    5 | d    |
  +------+------+
  2 rows in set (0.00 sec)
  ```

  FROM 后面放的是表名，这种由子查询结果集组成的表称之为**派生表**。

- WHERE 或 ON 子句

  最常用的一种用法。

  ```sql
  mysql> SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
  +------+------+
  | m1   | n1   |
  +------+------+
  |    2 | b    |
  |    3 | c    |
  +------+------+
  2 rows in set (0.00 sec)
  ```

- ORDER BY / GROUP BY 子句中

  虽然支持，没啥意义。

##### 按返回的结果集区分子查询

- 标量子查询 - 只返回单一值的子查询 (相当于返回一行一列)

  比如：`SELECT (SELECT m1 FROM t1 LIMIT 1);`，或 `SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);`。

  这两个子查询都返回一个单一值，即标量。这些标量子查询可以作为一个单一值或者表达式出现在外层查询的各个地方。

- 行子查询 - 返回一条记录，且这条记录包含多列

  比如：`SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);`。(哦，还可以同时进行多列比较，像这样：`WHERE (m1, n1) = (?, ?)`)

- 列子查询 - 返回一列记录，但包含多行

  比如：`SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);`。

- 表子查询 - 返回多行多列记录

  比如：`SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);`。

##### 按与外层查询关系来区分子查询

- 不相关子查询

  子查询可以单独运行出结果，而不依赖于外层查询的值。上面的例子全是不相关子查询。

- 相关子查询

  子查询的执行需要依赖于外层查询的值。比如：`SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);`。(那不是互相依赖了吗？)

##### 子查询在布尔表达式中的使用

虽然子查询可以出现在外层查询的各个地方，但像 `SELECT (SELECT m1 FROM t1 LIMIT 1);` 这种语句其实没啥意义。平时用子查询最多的地方就是把它作为布尔表达式的一部分来作为搜索条件用在 WHERE 子句或者 ON 子句里。

- 用于比较：`=`, `>`, `<`...

  `操作数 comparison_operator (子查询)`

  这里子查询只能是标量或行子查询。比如：

  ```sql
  SELECT * FROM t1 WHERE m1 < (SELECT MIN(m2) FROM t2);
  SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);
  ```

- 用于包含：`[NOT] IN/ANY/SOME/ALL`

  - `[NOT] IN` - `操作数 [NOT] IN (子查询)`

    ```sql
    SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
    ```

  - `ANY/SOME` - `操作数 comparison_operator ANY/SOME(子查询)`

    ```sql
    SELECT * FROM t1 WHERE m1 > ANY(SELECT m2 FROM t2);
    // 待价于
    SELECT * FROM t1 WHERE m1 > (SELECT MIN(m2) FROM t2);
    ```

    `=ANY` 和 IN 是一样的效果。

  - `ALL` - `操作数 comparison_operator ALL(子查询)`

    ```sql
    SELECT * FROM t1 WHERE m1 > ALL(SELECT m2 FROM t2);
    // 等价于
    SELECT * FROM t1 WHERE m1 > (SELECT MAX(m2) FROM t2);
    ```

- EXIST 子查询 - `[NOT] EXISTS (子查询)`

  不在乎子查询结果具体是啥，只在乎子查询有没有结果。

  ```sql
  SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2);
  ```

##### 子查询语法注意事项

- 子查询必须用小括号括起来

- 在 SELECT 子句中的子查询必须是标量子查询

- 在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用 `LIMIT 1` 语句来限制记录数量

- 对于 `[NOT] IN/ANY/SOME/ALL` 子查询来说，子查询中不允许有 LIMIT 语句

  在这类子查询中，对子查询结果的排序，去重都不关心，所以这些子查询中 `order by`, `distinct` 没啥意义。

- 不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询

#### 子查询在 MySQL 中是怎么执行的

不同类型的子查询有不同的执行方式，有些和我们想的相似，即简单地先单独执行子查询，再将结果作为外层查询的参数进行查询；有些较复杂，会转换成内连接或半连接。

##### 标量子查询、行子查询的执行方式

如果是不相关的子查询，和我们想象的一样：

```sql
SELECT * FROM s1
    WHERE key1 = (SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1);
```

先单独执行子查询，将结果作为外层查询参数再进行一次查询。

> 对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL 会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。

如果是相关子查询，比如：

```sql
SELECT * FROM s1 WHERE
    key1 = (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3 LIMIT 1);
```

它的执行方式：

1. 先从外层查询中获取一条记录，本例中也就是先从 s1 表中获取一条记录。
1. 将 s1.key3 代入子查询中，执行子查询
1. 根据子查询的结果来检测外层查询的 WHERE 子句是否成立，成立则将结果加入结果集，否则丢弃
1. 再回到第一步继续重复执行，依此类推

(但我觉得实际肯定一次性批量拿到多条 s1 后再将 s1.key3 代入子查询执行子查询)

##### IN 子查询优化

(IN 子查询是最常用，所以 MySQL 对它进行了许多优化，在某些条件下将它转成 inner join 或 semi-join)

**物化表**

对于不相关的 IN 子查询，比如：

```sql
SELECT * FROM s1
    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
```

如果子查询的结果很少，只有一两条，那么对子查询和外层查询单独执行，效率也很高。但如果子查询的结果集非常非常多，那么性能就变得特别差。

优化：将子查询的结果集写入一个临时表中。过程如下：

1. 该临时表的列就是子查询结果集中的列。
1. 写入临时表的记录会被去重。(对列建唯一索引)
1. 一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用 Memory 存储引擎的临时表，而且会为该表建立**哈希索引**。
1. 如果子查询结果集太大，则转为存储到磁盘中，索引变为 B+ 树。

MySQL 将子查询结果集中的记录保存到临时表的过程称之为物化（Materialize），相应的临时表则称之为物化表。因为物化表中的记录都建立了索引，通过索引执行 IN 语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。

**物化表连接**

有了物化表后，其实上面的查询可以转换成外表和物化表的内连接：

```sql
SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val;
```

接着就可以继续使用对内连接的优化进行进一步的优化了。

**将子查询转换为 semi-join**

不通过物化表，直接将原始子查询转换成连接查询。

比如这个查询：

```sql
SELECT * FROM s1
    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
```

和内连接很相似：

```
SELECT s1.* FROM s1 INNER JOIN s2
    ON s1.key1 = s2.common_field
    WHERE s2.key3 = 'a';
```

不同的地方在于，对于后者来说，一条 s1 表记录可能和多条 s2 表记录匹配，最终的记录集中可能出现一条 s1 表记录重复多次，但前者 s1 表一条记录只出现一次。

对于 s1 表的某条记录来说，由于我们只关心 s2 表中是否存在记录满足 `s1.key1 = s2.common_field` 这个条件，而不关心具体有多少条记录与之匹配...MySQL 提出了一种**半连接 (semi-join)** 的概念：对于 s1 表的某条记录来说，我们只关心在 s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留 s1 表的记录。

转换后的内部 SQL 大约是这样：

```sql
SELECT s1.* FROM s1 SEMI JOIN s2
    ON s1.key1 = s2.common_field
    WHERE key3 = 'a';
```

实现方法 (先大致了解，细节先忽略)：

- Table pullout (子查询中的表上拉)

  如果 ON 条件中 s2 表相应的列是唯一二级索引 (意味着没有重复)，直接转换成内连接

- DuplicateWeedout execution strategy (重复值消除)

  通过中间临时表 `CREATE TABLE tmp (id PRIMARY KEY);` 消除重复，详略。

- LooseScan execution strategy (松散扫描)

- Semi-join Materialization execution strategy

- FirstMatch execution strategy (首次匹配)

**semi-join 的适用条件**

需要时再详细了解

**不适用于 semi-join 的情况**

需要时再详细了解

##### ANY/ALL 子查询优化

可以转换成 MAX/MIN 子查询，前面有例子。

##### [NOT] EXISTS 子查询的执行

需要时再详细了解

##### 对于派生表的优化

需要时再详细了解

总之，这一章就是告诉我们，MySQL 优化器会做很多事情，尽量帮我们优化 SQL 语句。但最好我们还是在源头能把 SQL 语句写得尽可能地好。

## 16. 查询优化的百科全书 —— Explain 详解（上）

用 explain 显示执行计划。这一章就是用来 explain 的结果。

```sql
mysql> EXPLAIN SELECT 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
```

各列的意义：

| 列名          | 描述                                                      |
| ------------- | --------------------------------------------------------- |
| id            | 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id |
| select_type   | SELECT 关键字对应的那个查询的类型                         |
| table         | 表名                                                      |
| partitions    | 匹配的分区信息                                            |
| type          | 针对单表的访问方法                                        |
| possible_keys | 可能用到的索引                                            |
| key           | 实际上使用的索引                                          |
| key_len       | 实际使用到的索引长度                                      |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息    |
| rows          | 预估的需要读取的记录条数                                  |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比              |
| Extra         | 一些额外的信息                                            |

### 执行计划输出中各列详解

#### table

查询计划每一行都是对某个表的单表查询，table 就表示这一行是对哪个表进行单表查询。

```sql
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
+----+-------------+-------+----
| id | select_type | table | ...
+----+-------------+-------+----
|  1 | SIMPLE      | s1    | ...
|  1 | SIMPLE      | s2    | ...
+----+-------------+-------+----
2 rows in set, 1 warning (0.00 sec)
```

#### id

对每一个 select 会分配一个独立的 id。对于连接查询来说，只有一个 select，但涉及多个表的查询，这些表对应相同的 id。但显示在前面的表为驱动表，显示在后面的表为被驱动表。

```sql
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2;
+----+-------------+-------+----
| id | select_type | table | ...
+----+-------------+-------+----
|  1 | SIMPLE      | s1    | ...
|  1 | SIMPLE      | s2    | ...
+----+-------------+-------+----
```

对于子查询来说，涉及多个 select 关键字，每个 select 会对应一个唯一的 id 值。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
+----+--------------------+-------+----
| id | select_type        | table | ...
+----+--------------------+-------+----
|  1 | PRIMARY            | s1    | ...
|  2 | DEPENDENT SUBQUERY | s2    | ...
+----+--------------------+-------+----
```

如果查询优化器对子查询进行了重写，转换成了连接查询，可以从执行计划中看出，下面的执行计划两个表使用了相同的 id，表示转换成了连接查询。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = 'a');
+----+-------------+-------+----
| id | select_type | table | ...
+----+-------------+-------+----
|  1 | SIMPLE      | s1    | ...
|  1 | SIMPLE      | s2    | ...
+----+-------------+-------+----
```

UNION，最后会做一个内部合并去重操作，所以会增加一行 id 为 NULL 的步骤。

```sql
mysql> EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;
+------+--------------+------------+-
| id   | select_type  | table      |
+------+--------------+------------+-
|  1   | PRIMARY      | s1         |
|  2   | UNION        | s2         |
| NULL | UNION RESULT | <union1,2> |
+----+--------------+------------+---
```

#### select_type

顾名思义，是指每一个 select 的类型。有这些值：SIMPLE / PRIMARY / UNION / UNION RESULT / SUBQUERY / DEPENDENT SUBQUERY / DEPENDENT UNION / DERIVED / MATERIALIZED / UNCACHEABLE SUBQUERY / UNCACHEABLE UNION

具体每个类型用于哪些查询，先暂时跳过，实践中不理解再回来看。

#### partitions

一般都为 NULL，具体是啥小册上也没说，很少遇到。

#### type

对单表查询的访问方法，比如 const / ref / index 之类的。完整的值类型：system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index，ALL。

详细内容先跳过，需要时再细看。

#### possible_keys 和 key

possible_keys 表示查询时可能用到的索引，key 表示实际用到的索引。

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
+----+-------------+-------+------------+------+-------------------+----------+-
| id | select_type | table | partitions | type | possible_keys     | key      |
+----+-------------+-------+------------+------+-------------------+----------+-
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 |
+----+-------------+-------+------------+------+-------------------+----------|-
```

当直接使用 index 的访问方法时 (即 type 的值为 index)，possible_keys 为 NUL，key 为用到的索引。很好理解嘛，因为这时用哪个索引已经是确定的了，不需要查询优化器在多个索引之间比较。所以 possible_keys 不是越多越好，及时删除不再需要的索引。

#### key_len

表示查询用到的索引列的长度。详细计算方法暂略。

#### ref

当使用索引列等值匹配的条件去执行查询时，ref 列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。

详略。

#### rows

如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。

#### filtered

用来计算连接查询时驱动表的扇出值。比如对于驱动表来说 rows 为 9688，filtered 为 10.00，则驱动表的扇出值为 `9688 x 10% = 968`。

---

不过，TiDB 和 PostgreSQL 看到的执行计划的输出格式不是这样的啊...不是应该还有 Table Scan / Index Scan 之类的吗？

PostgreSQL 中的一个[例子](https://ruby-china.org/topics/38152)：

```sql
[1] pry(main)> Episode.search_by_title('adventure').explain
  Episode Load (85.9ms)  SELECT "episodes".* FROM "episodes" INNER JOIN (...
                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Sort  (cost=4050.16..4051.01 rows=341 width=1513)
   Sort Key: (ts_rank(episodes_1.tsv_title, '''adventure'':*'::tsquery, 2)) DESC, episodes.id
   ->  Nested Loop  (cost=34.96..4035.81 rows=341 width=1513)
         ->  Bitmap Heap Scan on episodes episodes_1  (cost=34.54..1306.26 rows=327 width=103)
               Recheck Cond: (tsv_title @@ '''adventure'':*'::tsquery)
               ->  Bitmap Index Scan on index_episodes_on_tsv_title  (cost=0.00..34.45 rows=327 width=0)
                     Index Cond: (tsv_title @@ '''adventure'':*'::tsquery)
         ->  Index Scan using episodes_pkey on episodes  (cost=0.42..8.34 rows=1 width=1509)
               Index Cond: (id = episodes_1.id)
(9 rows)
```

## 17. 查询优化的百科全书 —— Explain 详解（下）

这一章主要讲的是上一章遗留的执行计划中的 extra 列的意义。

> Extra 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解 MySQL 到底将如何执行给定的查询语句。

extra 列中常见的值：

- No tables used
- Impossible WHERE
- No matching min/max row
- Using index
- Using index condition (索引条件下推)
- Using where
- Using join buffer (Block Nested Loop)
- Not exists
- Using intersect(...)、Using union(...) 和 Using sort_union(...)
- Zero limit
- Using filesort
- Using temporary
- Start temporary, End temporary
- LooseScan
- FirstMatch(tbl_name)

详细细节先跳过，实践中遇到再回头。

### JSON 格式的执行计划

在 EXPLAIN 后加上 `FORMAT=JSON` 可以得到 json 格式的执行计划，里面包含表格形式缺失的成本的内容。

详略。

### Extented EXPLAIN

在执行完 EXPLAIN 后紧接着马上执行 `SHOW WARNINGS` 语句可以得到和刚查询的执行计划相关的一些扩展信息。

比如：

```sql
mysql> EXPLAIN SELECT ...
...

mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `xiaohaizi`.`s1`.`key1` AS `key1`,`xiaohaizi`.`s2`.`key1` AS `key1` from `xiaohaizi`.`s1` join `xiaohaizi`.`s2` where ((`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key1`) and (`xiaohaizi`.`s2`.`common_field` is not null))
```

常见的是 Code 为 1003 的信息，当 Code 为 1003 时，Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。但注意它显示的是内部 SQL 语句，并不一定能在 MySQL 的 client 端里直接运行。

## 18. 神兵利器 —— optimizer trace 的神奇功效

本章介绍 MySQL 提供的 optimizer trace 功能，它可以让我们方便的查看优化器生成执行计划的整个过程。

开启和关闭由系统变量 optimizer_trace 决定。

```sql
mysql> SHOW VARIABLES LIKE 'optimizer_trace';
+-----------------+--------------------------+
| Variable_name   | Value                    |
+-----------------+--------------------------+
| optimizer_trace | enabled=off,one_line=off |
+-----------------+--------------------------+
```

完整步骤：

```sql
# 1. 打开optimizer trace功能 (默认情况下它是关闭的):
SET optimizer_trace="enabled=on";

# 2. 这里输入你自己的查询语句
SELECT ...;

# 3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程
SELECT * FROM information_schema.OPTIMIZER_TRACE;

# 4. 可能你还要观察其他语句执行的优化过程，重复上边的第2、3步
...

# 5. 当你停止查看语句的优化过程时，把optimizer trace功能关闭
SET optimizer_trace="enabled=off";
```

OPTIMIZER_TRACE 表有 4 列，分别是 QUERY / TRACE / MISSING_BYTES_BEYOND_MAX_MEM_SIZE / INSUFFICIENT_PRIVILEGES，详略。

优化过程分三个阶段：prepare / optimize / execute。

## 19. 调节磁盘和 CPU 的矛盾 —— InnoDB 的 Buffer Pool

这一节讲的是 MySQL 的缓存系统。如果每次查询都直接去访问硬盘，那就太慢了，所以 MySQL 设计了缓存系统 Buffer Pool，将访问过或即将访问的内容放到了内存中，操作单位是页。

这一章的细节先跳过，需要时再细看，先知道其大致工作原理就行。

使用多个链表来管理 Butter Pool，比如 free 链表，flush 链表。

Buffer Pool 的更新使用 LRU 链表。

在 Buffer Pool 中被修改的页称为脏页，脏页并不是立即刷新，而是被加入到 flush 链表中，待之后的某个时刻同步到磁盘上。

## 20. 从猫爷被杀说起 —— 事务简介

事务，英文是 transaction，原意是交易。

类似转账这种操作，要么失败，要么成功，不能有中间状态。

实现事物的几条规则 - ACID

- A: Atomicity 原子性
- I: Isolation 隔离性
- C: Consistency 一致性
- D: Duration 持久性

原子性好理解，要么全做，要么全不做 (回滚)。

隔离性，A 向 B 转账，10 元分两次转账，每次 5 元，这两次转账之间是相互隔离没有关系的。

一致性，比如 A 向 B 转账后，A 的余额不能为 0，A 和 B 的总额保持不变，这就是一致性。一致性可以在数据库内部保证，加 check 语句，但比较影响性能，一般在业务层来做。比如在业务层判断如果转账后 A 的余额为负数 (即转出数大于余额数) 则不允许转账。

> 数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。

持久性也好理解，转账结果一定要永久保存，进行持久化。

### 事务的概念

> 把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务（英文名是：transaction）

事务的 5 个状态：

![](../art/mysql-inside/transactions_status.png)

### MySQL 中事务的语法

#### 开启事物

两种写法：

- `BEGIN WORK;` (`WORK` 可以省略)
- `START TRANSACTION;`

后者可以跟一些修饰符，比如 `READ ONLY`, `READ WRITE`, `WITH CONSISTENT SNAPSHOT`。前两个好理解，第三个表示开启一致性读。(后面会解释)

示例：`START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT;`。

#### 提交事物

`COMMIT WORK;`，`WORK` 可以省略。

#### 手动终止事物

`ROLLBACK WORK;`，`WORK` 可以省略。

### 支持事物的存储引擎

InnoDB 支持事物，MyISAM 不支持。

### 自动提交

如果变量 `autocommit` 为 ON，那么默认每一条 SQL 语句都是事物，不需要显式的 begin/commit，如果想关闭自动提交，两种方法：

- 显式地使用 begin/commit
- 设置 `autocommit` 为 OFF

### 隐式提交

某些语句会自动触发 commit。

- DDL 语句

  DDL，定义或修改数据库对象的数据定义语言。

  所谓的数据库对象，指的就是数据库、表、视图、存储过程等等这些东西。当我们使用 CREATE、ALTER、DROP 等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务。

  相对应的 DML 其实就是指 CRUD 中的 CUD。

- 隐式使用或修改 mysql 数据库中的表

  ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD 等语句。

- 事务控制或关于锁定的语句

  当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。

- 其它，略...

### 保存点

```sql
SAVEPOINT save_point_name;
...
ROLLBACK TO save_point_name;
```

## 21. 说过的话就一定要办到 —— redo 日志（上）

(细节先跳过，需要时再了解)

前面说到，修改行记录时，并不会马上落盘，而只是在缓存中修改。为什么不落盘，原因有二：

- 可能仅仅修改了一个页面中的一个字节，却要刷新一个完整页的内容到磁盘中，太浪费了
- 随机 IO 刷新起来比较慢

但让修改记录一直在缓存中也不保险，如果出现突发情况，比如断电，进程被杀，那修改就会丢失。

解决办法：只需要把修改了哪些东西记录一下就好。这些被称为 redo log。

- redo 日志占用的空间非常小
- redo 日志是顺序写入磁盘的

### redo 日志格式

redo 日志本质上只是记录了一下事务对数据库做了哪些修改。为了尽可能节省空间，定义了多达 53 种格式。

通用格式：

```
type | spaceID | page number | data
```

细节，暂略。

redo 日志格式小结：redo 日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。

### Mini-Transaction

以组的形式写入 redo 日志，保证原子性。

redo log 也有缓存。
